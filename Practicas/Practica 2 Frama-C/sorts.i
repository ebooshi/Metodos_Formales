/* Generated by Frama-C */
typedef unsigned long size_t;
typedef int wchar_t;
typedef long __off_t;
typedef long __off64_t;
struct __e_acsl_contract_t;
typedef struct __e_acsl_contract_t __attribute__((__FC_BUILTIN__)) __e_acsl_contract_t;
struct __e_acsl_mpz_struct {
   int _mp_alloc ;
   int _mp_size ;
   unsigned long *_mp_d ;
};
typedef struct __e_acsl_mpz_struct __e_acsl_mpz_struct;
typedef __e_acsl_mpz_struct ( __attribute__((__FC_BUILTIN__)) __e_acsl_mpz_t)[1];
struct __e_acsl_mpq_struct {
   __e_acsl_mpz_struct _mp_num ;
   __e_acsl_mpz_struct _mp_den ;
};
typedef struct __e_acsl_mpq_struct __e_acsl_mpq_struct;
typedef __e_acsl_mpq_struct ( __attribute__((__FC_BUILTIN__)) __e_acsl_mpq_t)[1];
typedef unsigned long __e_acsl_mp_bitcnt_t;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[((unsigned long)15 * sizeof(int) - (unsigned long)4 * sizeof(void *)) - sizeof(size_t)] ;
};
extern size_t __e_acsl_heap_allocation_size;

extern size_t __e_acsl_heap_allocated_blocks;

/*@ ghost extern int __fc_heap_status; */

/*@
axiomatic dynamic_allocation {
  predicate is_allocable{L}(ℤ n) 
    reads __fc_heap_status;
  
  axiom never_allocable{L}:
    ∀ ℤ i; i < 0 ∨ i > 18446744073709551615UL ⇒ ¬is_allocable(i);
  
  }
 */
/*@ ghost extern int __e_acsl_init; */

long valid_nstring(char *s, long n, int wrtbl);

long valid_nwstring(wchar_t *s, long n, int wrtbl);

__inline static long valid_string__fc_inline(char *s, int wrtbl)
{
  long tmp;
  tmp = valid_nstring(s,(long)(-1),wrtbl);
  return tmp;
}

__inline static long valid_wstring__fc_inline(wchar_t *s, int wrtbl)
{
  long tmp;
  tmp = valid_nwstring(s,(long)(-1),wrtbl);
  return tmp;
}

void swap(int *x, int *y)
{
  int temp = *x;
  *x = *y;
  *y = temp;
  return;
}

void selectionSort(int *arr, int n)
{
  int i;
  int j;
  int min_idx;
  i = 0;
  while (i < n - 1) {
    min_idx = i;
    j = i + 1;
    while (j < n) {
      if (*(arr + j) < *(arr + min_idx)) min_idx = j;
      j ++;
    }
    swap(arr + i,arr + min_idx);
    i ++;
  }
  return;
}

void insertionSort(int *arr, int n)
{
  int i;
  int key;
  int j;
  i = 1;
  while (i < n) {
    key = *(arr + i);
    j = i - 1;
    while (1) {
      if (j >= 0) {
        if (! (*(arr + j) >= key)) break;
      }
      else break;
      *(arr + (j + 1)) = *(arr + j);
      j --;
    }
    *(arr + (j + 1)) = key;
    i ++;
  }
  return;
}

int main(void)
{
  int __retres;
  int arr[5] = {64, 25, 12, 22, 11};
  int n = (int)(sizeof(arr) / sizeof(arr[0]));
  selectionSort(arr,n);
  int arr2[5] = {64, 25, 12, 22, 11};
  int n2 = (int)(sizeof(arr2) / sizeof(arr2[0]));
  insertionSort(arr2,n2);
  __retres = 0;
  return __retres;
}


